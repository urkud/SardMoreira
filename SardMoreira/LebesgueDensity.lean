import Mathlib.MeasureTheory.Constructions.Polish.Basic
import Mathlib.MeasureTheory.Covering.Besicovitch
import Mathlib.MeasureTheory.Measure.Prod
import Mathlib.Topology.Order.LowerUpperTopology
import SardMoreira.UpperLowerSemicontinuous

open scoped ENNReal
open MeasureTheory Filter Set Function Metric Topology

theorem MeasureTheory.tendsto_measure_biUnion_lt {Œ± : Type*} {m : MeasurableSpace Œ±}
    {Œº : Measure Œ±} {Œπ : Type*} [LinearOrder Œπ] [TopologicalSpace Œπ] [OrderTopology Œπ]
    [DenselyOrdered Œπ] [FirstCountableTopology Œπ] {s : Œπ ‚Üí Set Œ±} {a : Œπ}
    (hm : ‚àÄ i j, i ‚â§ j ‚Üí j < a ‚Üí s i ‚äÜ s j) :
    Tendsto (Œº ‚àò s) (ùìù[<] a) (ùìù (Œº (‚ãÉ i < a, s i))) := by
  have : (atTop : Filter (Iio a)).IsCountablyGenerated := by
    rw [‚Üê comap_coe_Iio_nhdsLT]
    infer_instance
  simp_rw [‚Üê map_coe_Iio_atTop, tendsto_map'_iff, ‚Üê mem_Iio, biUnion_eq_iUnion]
  exact tendsto_measure_iUnion_atTop fun i j hle ‚Ü¶ hm i j hle j.2

theorem continuousWithinAt_Iio_measure_ball {X : Type*} [PseudoMetricSpace X]
    {_ : MeasurableSpace X} {Œº : Measure X} {x : X} {r : ‚Ñù} :
    ContinuousWithinAt (Œº <| ball x ¬∑) (Iio r) r := by
  rw [ContinuousWithinAt, ‚Üê biUnion_lt_ball]
  exact tendsto_measure_biUnion_lt fun i j hle _ ‚Ü¶ by gcongr

theorem continuousWithinAt_Iic_measure_ball {X : Type*} [PseudoMetricSpace X]
    {_ : MeasurableSpace X} {Œº : Measure X} {x : X} {r : ‚Ñù} :
    ContinuousWithinAt (Œº <| ball x ¬∑) (Iic r) r :=
  continuousWithinAt_Iio_iff_Iic.mp continuousWithinAt_Iio_measure_ball

theorem lowerSemicontinuous_measure_ball_toUpper_symm {X : Type*} [PseudoMetricSpace X]
    {_ : MeasurableSpace X} {Œº : Measure X} :
    LowerSemicontinuous fun xr : X √ó WithUpper ‚Ñù ‚Ü¶ Œº (ball xr.1 (WithUpper.toUpper.symm xr.2)) := by
  simp only [LowerSemicontinuous, Prod.forall, WithUpper.toUpper.surjective.forall,
    LowerSemicontinuousAt, Equiv.symm_apply_apply]
  intro x r m hm
  obtain ‚ü®r‚ÇÅ, hr‚ÇÅ, hmr‚ÇÅ‚ü© : ‚àÉ r‚ÇÅ < r, m < Œº (ball x r‚ÇÅ) :=
    (eventually_mem_nhdsWithin.and
      (continuousWithinAt_Iio_measure_ball.eventually_const_lt hm)).exists
  obtain ‚ü®r‚ÇÇ, hr‚ÇÅr‚ÇÇ, hr‚ÇÇr‚ü© : ‚àÉ r‚ÇÇ, r‚ÇÅ < r‚ÇÇ ‚àß r‚ÇÇ < r := exists_between hr‚ÇÅ
  have H : ‚àÄ·∂† xr : X √ó WithUpper ‚Ñù in ùìù (x, WithUpper.toUpper r),
      xr.1 ‚àà ball x (r‚ÇÇ - r‚ÇÅ) ‚àß r‚ÇÇ < WithUpper.toUpper.symm xr.2 :=
    prod_mem_nhds (ball_mem_nhds _ (sub_pos.2 hr‚ÇÅr‚ÇÇ)) (eventually_gt_nhds hr‚ÇÇr)
  refine H.mono ?_
  simp only [Prod.forall, WithUpper.toUpper.surjective.forall, Equiv.symm_apply_apply, mem_ball]
  rintro y r' ‚ü®hy, hr'‚ü©
  refine hmr‚ÇÅ.trans_le <| measure_mono <| ball_subset_ball' ?_
  rw [dist_comm]
  linarith

theorem lowerSemicontinuous_measure_ball {X : Type*} [PseudoMetricSpace X]
    {_ : MeasurableSpace X} {Œº : Measure X} :
    LowerSemicontinuous fun xr : X √ó ‚Ñù ‚Ü¶ Œº (ball xr.1 xr.2) :=
  lowerSemicontinuous_measure_ball_toUpper_symm.comp_continuous <|
    continuous_id.prodMap WithUpper.continuous_toUpper

@[fun_prop]
theorem Measurable.measure_ball {Œ± X : Type*} {_ : MeasurableSpace Œ±}
    [PseudoMetricSpace X] [MeasurableSpace X] [OpensMeasurableSpace X] {Œº : Measure X}
    {f : Œ± ‚Üí X} {g : Œ± ‚Üí ‚Ñù} (hf : Measurable f) (hg : Measurable g) :
    Measurable (fun a ‚Ü¶ Œº (ball (f a) (g a))) :=
  lowerSemicontinuous_measure_ball.measurable.comp (hf.prod_mk hg)

theorem IsCompact.exists_isMinOn_measure_ball {X : Type*} [PseudoMetricSpace X]
    [MeasurableSpace X] [OpensMeasurableSpace X] (Œº : Measure X) {s : Set X}
    (hs : IsCompact s) (hne : s.Nonempty) (r : ‚Ñù) : ‚àÉ x ‚àà s, IsMinOn (Œº <| ball ¬∑ r) s x :=
  ((lowerSemicontinuous_measure_ball.comp_continuous
    (continuous_id.prod_mk continuous_const)).lowerSemicontinuousOn _).exists_isMinOn hs hne

theorem IsCompact.exists_pos_forall_lt_measure_ball {X : Type*} [PseudoMetricSpace X]
    [MeasurableSpace X] [OpensMeasurableSpace X] (Œº : Measure X) [Œº.IsOpenPosMeasure] {s : Set X}
    (hs : IsCompact s) {r : ‚Ñù} (hr : 0 < r) : ‚àÉ m > 0, ‚àÄ x ‚àà s, m < Œº (ball x r) := by
  rcases s.eq_empty_or_nonempty with rfl | hne
  ¬∑ use 1
    simp
  ¬∑ rcases hs.exists_isMinOn_measure_ball Œº hne r with ‚ü®x, hxs, hx‚ü©
    rcases exists_between (Metric.measure_ball_pos Œº x hr) with ‚ü®m, hm‚ÇÄ, hmx‚ü©
    exact ‚ü®m, hm‚ÇÄ, fun y hy ‚Ü¶ hmx.trans_le <| hx hy‚ü©

theorem exists_pos_forall_lt_measure_ball {X : Type*} [PseudoMetricSpace X] [CompactSpace X]
    [MeasurableSpace X] [OpensMeasurableSpace X] (Œº : Measure X) [Œº.IsOpenPosMeasure]
    {r : ‚Ñù} (hr : 0 < r) : ‚àÉ m > 0, ‚àÄ x, m < Œº (ball x r) := by
  simpa using isCompact_univ.exists_pos_forall_lt_measure_ball Œº hr

/-- If $s_b$ is a family of sets such that $\{(a, b) \mid a \in s_b\}$ is a measurable set,
then for any s-finite measure $\mu$, the function $b \mapsto \mu(s_b)$ is measurable.

This is a version of `measurable_measure_prod_mk_right`. -/
theorem Measurable.measure_apply {Œ± Œ≤ : Type*} [MeasurableSpace Œ±] [MeasurableSpace Œ≤]
    (Œº : Measure Œ±) [SFinite Œº] (s : Œ≤ ‚Üí Set Œ±) (hs : MeasurableSet {p : Œ± √ó Œ≤ | p.1 ‚àà s p.2}) :
    Measurable fun b ‚Ü¶ Œº (s b) :=
  measurable_measure_prod_mk_right hs

theorem Metric.biInter_lt_rat_closedBall {X : Type*} [PseudoMetricSpace X] (x : X) (r : ‚Ñù) :
    closedBall x r = ‚ãÇ (q : ‚Ñö) (_ : r < q), closedBall x q := by
  ext
  simpa only [mem_iInter‚ÇÇ, mem_closedBall] using le_iff_forall_lt_rat_imp_le

theorem eventually_measure_closedBall_lt_top
    {X : Type*} [PseudoMetricSpace X] [MeasurableSpace X]
    (Œº : Measure X) [IsLocallyFiniteMeasure Œº] (x : X) :
    ‚àÄ·∂† r in ùìù 0, Œº (closedBall x r) < ‚ä§ := by
  rcases (Œº.finiteAt_nhds x).exists_mem_basis nhds_basis_closedBall with ‚ü®Œµ, Œµ‚ÇÄ, hŒµ‚ü©
  exact (eventually_lt_nhds Œµ‚ÇÄ).mono fun r hr ‚Ü¶ lt_of_le_of_lt (by gcongr) hŒµ

theorem eventually_forall_le_continuousWithinAt_Ici_measure_closedBall
    {X : Type*} [PseudoMetricSpace X] [MeasurableSpace X] [OpensMeasurableSpace X]
    (Œº : Measure X) [IsLocallyFiniteMeasure Œº] (x : X) :
    ‚àÄ·∂† r : ‚Ñù in ùìù 0, ‚àÄ ŒΩ ‚â§ Œº, ContinuousWithinAt (ŒΩ <| closedBall x ¬∑) (Set.Ici r) r := by
  rcases (Œº.finiteAt_nhds x).exists_mem_basis nhds_basis_closedBall with ‚ü®Œµ, Œµ‚ÇÄ, hŒµ‚ü©
  filter_upwards [eventually_lt_nhds Œµ‚ÇÄ] with r hr ŒΩ hŒΩ
  rw [‚Üê continuousWithinAt_Ioi_iff_Ici, ContinuousWithinAt]
  convert tendsto_measure_biInter_gt (by measurability) (by intros; gcongr)
    ‚ü®Œµ, hr, ((hŒΩ _).trans_lt hŒµ).ne‚ü©
  rw [biInter_gt_closedBall]

theorem eventually_continuousWithinAt_Ici_measure_inter_closedBall_div
    {X : Type*} [PseudoMetricSpace X] [MeasurableSpace X] [OpensMeasurableSpace X]
    {Œº : Measure X} [IsLocallyFiniteMeasure Œº] (x : X) {s : Set X} (hs : NullMeasurableSet s Œº) :
    ‚àÄ·∂† r : ‚Ñù in ùìù[>] 0,
      ContinuousWithinAt (fun r ‚Ü¶ Œº (s ‚à© closedBall x r) / Œº (closedBall x r)) (Set.Ici r) r := by
  by_cases h‚ÇÄ : ‚àÉ Œµ > 0, Œº (closedBall x Œµ) = 0
  case pos =>
    rcases h‚ÇÄ with ‚ü®Œµ, Œµ‚ÇÄ, hŒµ‚ü©
    filter_upwards [Ioo_mem_nhdsGT Œµ‚ÇÄ] with r hr
    refine (continuousAt_const.congr (f := 0) ?_).continuousWithinAt
    filter_upwards [eventually_lt_nhds hr.2] with r' hr'
    rw [measure_mono_null _ hŒµ, ENNReal.zero_div, Pi.zero_apply]
    exact inter_subset_right.trans (by gcongr)
  case neg =>
    rw [eventually_nhdsWithin_iff]
    filter_upwards [eventually_measure_closedBall_lt_top Œº x,
      eventually_forall_le_continuousWithinAt_Ici_measure_closedBall Œº x] with r hr‚ÇÅ hr‚ÇÇ hr‚ÇÄ
    refine ENNReal.Tendsto.div ?_ (by simp_all) (hr‚ÇÇ _ le_rfl) (.inl hr‚ÇÅ.ne)
    simp only [inter_comm s, ‚Üê Measure.restrict_apply‚ÇÄ' hs]
    exact hr‚ÇÇ _ Measure.restrict_le_self

theorem eventually_nhdsWithin_nhds {X : Type*} [TopologicalSpace X] {U : Set X} (hU : IsOpen U)
    {p : X ‚Üí Prop} {x : X} :
    (‚àÄ·∂† y in ùìù[U] x, ‚àÄ·∂† z in ùìù y, p z) ‚Üî ‚àÄ·∂† y in ùìù[U] x, p y := by
  conv_rhs => rw [‚Üê eventually_eventually_nhdsWithin]
  refine eventually_congr <| eventually_mem_nhdsWithin.mono fun y hy ‚Ü¶ ?_
  rw [hU.nhdsWithin_eq hy]

theorem IsDenseEmbedding.tendsto_nhdsWithin_preimage_iff_of_eventually_continuousWithinAt
    {X Y Z : Type*} [TopologicalSpace X] [TopologicalSpace Y]
    [TopologicalSpace Z] [RegularSpace Z]
    {e : X ‚Üí Y} {s : Set Y} {x : X} {z : Z} {f : Y ‚Üí Z} {U : Y ‚Üí Set Y} [‚àÄ y, (ùìù[U y] y).NeBot]
    (he : IsDenseEmbedding e) (hs : IsOpen s) (hU : ‚àÄ y, IsOpen (U y))
    (hcont : ‚àÄ·∂† y in ùìù[s] (e x), ContinuousWithinAt f (U y) y) :
    Tendsto (f ‚àò e) (ùìù[e ‚Åª¬π' s] x) (ùìù z) ‚Üî Tendsto f (ùìù[s] (e x)) (ùìù z) := by
  refine ‚ü®fun h ‚Ü¶ ?mp, fun h ‚Ü¶ h.comp ?mpr‚ü©
  case mpr =>
    exact he.continuous.continuousWithinAt.tendsto_nhdsWithin (mapsTo_preimage _ _)
  case mp =>
    rw [(closed_nhds_basis z).tendsto_right_iff]
    rintro V ‚ü®hV, hVc‚ü©
    rw [‚Üê tendsto_map'_iff, he.isEmbedding.map_nhdsWithin_eq, image_preimage_eq_inter_range] at h
    replace h := h.eventually (eventually_mem_set.mpr hV)
    rw [nhdsWithin_inter', eventually_inf_principal, ‚Üê eventually_nhdsWithin_nhds hs] at h
    filter_upwards [hcont, h] with y hy‚ÇÅ hy‚ÇÇ
    refine hVc.mem_of_frequently_of_tendsto ?_ hy‚ÇÅ
    refine .mp ?_ (eventually_nhdsWithin_of_eventually_nhds hy‚ÇÇ)
    rw [(nhdsWithin_basis_open _ _).frequently_iff]
    rintro W ‚ü®hyW, hWo‚ü©
    simp only [mem_inter_iff, @and_comm _ (_ ‚àà range e), exists_range_iff]
    apply he.dense.exists_mem_open (hWo.inter (hU y))
    rw [inter_comm]
    exact nonempty_of_mem <| inter_mem_nhdsWithin _ (hWo.mem_nhds hyW)

theorem tendsto_measure_inter_closedBall_div_iff_rat
    {X : Type*} [PseudoMetricSpace X] [MeasurableSpace X] [OpensMeasurableSpace X]
    {Œº : Measure X} [IsLocallyFiniteMeasure Œº] {x : X} {a : ‚Ñù‚â•0‚àû} {s : Set X}
    (hs : NullMeasurableSet s Œº) :
    Tendsto (fun r ‚Ü¶ Œº (s ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù a) ‚Üî
      Tendsto (fun r : ‚Ñö ‚Ü¶ Œº (s ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù a) := by
  rw [‚Üê Rat.cast_zero (Œ± := ‚Ñù), ‚Üê Rat.preimage_cast_Ioi (K := ‚Ñù),
    ‚Üê Rat.isDenseEmbedding_coe_real.tendsto_nhdsWithin_preimage_iff_of_eventually_continuousWithinAt
      (U := Ioi), comp_def]
  ¬∑ exact isOpen_Ioi
  ¬∑ exact fun _ ‚Ü¶ isOpen_Ioi
  ¬∑ simp only [Rat.cast_zero, continuousWithinAt_Ioi_iff_Ici]
    exact eventually_continuousWithinAt_Ici_measure_inter_closedBall_div _ hs

-- The next 2 lemmas depend on Polish spaces,
-- because they are formulated for a measurable `f`.
-- However, we always apply them to simple functions.
-- We may decide to reformulate in order to reduce dependencies.
theorem MeasurableSet.setOf_tendsto_measure_sectl_inter_closedBall_div
    {X : Type*} [PseudoMetricSpace X] [SecondCountableTopology X]
    [MeasurableSpace X] [OpensMeasurableSpace X]
    {Œ± : Type*} [MeasurableSpace Œ±]
    (Œº : Measure X) [IsLocallyFiniteMeasure Œº] [SFinite Œº]
    {s : Set (X √ó Œ±)} (hs : MeasurableSet s) {f : X √ó Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    MeasurableSet {p : X √ó Œ± |
      Tendsto (fun r : ‚Ñù ‚Ü¶ Œº ((¬∑, p.2) ‚Åª¬π' s  ‚à© closedBall p.1 r) / Œº (closedBall p.1 r)) (ùìù[>] 0)
        (ùìù (f p))} := by
  have hm : ‚àÄ {a}, MeasurableSet ((¬∑, a) ‚Åª¬π' s) := hs.preimage (by measurability)
  simp only [tendsto_measure_inter_closedBall_div_iff_rat hm.nullMeasurableSet]
  have {q} : MeasurableSet {p : X √ó X √ó Œ± | p.1 ‚àà closedBall p.2.1 q} := by
    simp only [mem_closedBall]
    apply measurableSet_le
    ¬∑ exact measurable_fst.dist measurable_snd.fst
    ¬∑ exact measurable_const
  refine measurableSet_tendsto_fun (fun q ‚Ü¶ .div ?_ (.measure_apply Œº _ this)) hf
  refine .measure_apply _ _ ?_
  exact .inter (hs.preimage <| .prod_mk measurable_fst measurable_snd.snd) this

theorem MeasurableSet.setOf_tendsto_measure_inter_closedBall_div
    {X : Type*} [PseudoMetricSpace X] [SecondCountableTopology X]
    [MeasurableSpace X] [OpensMeasurableSpace X]
    (Œº : Measure X) [IsLocallyFiniteMeasure Œº] [SFinite Œº]
    {s : Set X} (hs : MeasurableSet s) {f : X ‚Üí ‚Ñù‚â•0‚àû} (hf : Measurable f) :
    MeasurableSet {x : X |
      Tendsto (fun r ‚Ü¶ Œº (s  ‚à© closedBall x r) / Œº (closedBall x r)) (ùìù[>] 0) (ùìù (f x))} := by
  -- Another option is to apply the previous lemma to the product with `univ : Set Unit`,
  -- but repeating the proof is shorter in this case.
  simp only [tendsto_measure_inter_closedBall_div_iff_rat hs.nullMeasurableSet]
  have H {q} : MeasurableSet {p : X √ó X | p.1 ‚àà closedBall p.2 q} :=
    measurableSet_le (measurable_fst.dist measurable_snd) measurable_const
  refine measurableSet_tendsto_fun (fun q ‚Ü¶ .div (.measure_apply Œº _ ?_) (.measure_apply Œº _ H)) hf
  exact .inter (hs.preimage measurable_fst) H

/-- Parametrized version of `ae_tendsto_measure_inter_div_of_measurableSet`. -/
theorem Besicovitch.ae_tendsto_measure_sectl_inter_closedBall_div
    {X : Type*} [MetricSpace X] [SecondCountableTopology X] [HasBesicovitchCovering X]
    [MeasurableSpace X] [BorelSpace X]
    {Œ± : Type*} [MeasurableSpace Œ±]
    (Œº : Measure X) [IsLocallyFiniteMeasure Œº] [SFinite Œº] (ŒΩ : Measure Œ±) [SFinite ŒΩ]
    {s : Set (X √ó Œ±)} (hs : MeasurableSet s) :
    ‚àÄ·µê p ‚àÇŒº.prod ŒΩ, Tendsto (fun r ‚Ü¶ Œº ((¬∑, p.2) ‚Åª¬π' s  ‚à© closedBall p.1 r) / Œº (closedBall p.1 r))
      (ùìù[>] 0) (ùìù (s.indicator 1 p)) := by
  have H := hs.setOf_tendsto_measure_sectl_inter_closedBall_div Œº <|
    (measurable_const (a := 1)).indicator hs
  rw [Measure.ae_prod_iff_ae_ae, Measure.ae_ae_comm] <;> try exact H
  refine .of_forall fun y ‚Ü¶ ae_tendsto_measure_inter_div_of_measurableSet Œº <| hs.preimage ?_
  measurability
